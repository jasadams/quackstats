# name: test/sql/forecast_models.test
# group: quackstats

require quackstats

# ============================================================
# Setup: Create test data tables
# ============================================================

# Linear trend data (perfect line: y = 10 + 3*x)
statement ok
CREATE TABLE linear_trend AS
SELECT ('2025-01-01'::DATE + INTERVAL (i) DAY)::DATE AS ts,
       10.0 + i * 3.0 AS val
FROM generate_series(0, 49) t(i);

# Noisy data for interval width testing
statement ok
CREATE TABLE noisy_series AS
SELECT ('2025-01-01'::DATE + INTERVAL (i) DAY)::DATE AS ts,
       100.0 + i * 2.0 + (CASE WHEN i % 3 = 0 THEN 8.0 WHEN i % 3 = 1 THEN -5.0 ELSE 2.0 END) AS val
FROM generate_series(0, 39) t(i);

# Grouped data for grouped model tests
statement ok
CREATE TABLE grouped_data AS
SELECT ('2025-01-01'::DATE + INTERVAL (i) DAY)::DATE AS ds,
       grp,
       50.0 + i * 2.0 + (CASE WHEN grp = 'A' THEN 10 ELSE 0 END) AS val
FROM generate_series(0, 29) t(i),
     (VALUES ('A'), ('B')) AS groups(grp);

# ============================================================
# Test 1: model := 'ets' - explicit ETS model selection
# ============================================================

query I
SELECT count(*) FROM forecast('linear_trend', timestamp = 'ts', value = 'val', horizon = 5, model = 'ets');
----
5

# ETS forecast values should be positive and reasonable for upward trend
query I
SELECT count(*) FROM forecast('linear_trend', timestamp = 'ts', value = 'val', horizon = 3, model = 'ets')
WHERE forecast > 50.0;
----
3

# ============================================================
# Test 2: model := 'linear' - linear regression model
# ============================================================

query I
SELECT count(*) FROM forecast('linear_trend', timestamp = 'ts', value = 'val', horizon = 5, model = 'linear');
----
5

# Linear model on trending data should continue the upward trend
query I
SELECT count(*) FROM forecast('linear_trend', timestamp = 'ts', value = 'val', horizon = 3, model = 'linear')
WHERE forecast > 100.0;
----
3

# ============================================================
# Test 3: model := 'auto' - automatic model selection (default)
# ============================================================

query I
SELECT count(*) FROM forecast('linear_trend', timestamp = 'ts', value = 'val', horizon = 5, model = 'auto');
----
5

# Auto should also produce reasonable forecasts
query I
SELECT count(*) FROM forecast('linear_trend', timestamp = 'ts', value = 'val', horizon = 3, model = 'auto')
WHERE forecast > 50.0;
----
3

# Default model (no model param) should behave same as 'auto'
query I
SELECT count(*) FROM forecast('linear_trend', timestamp = 'ts', value = 'val', horizon = 5);
----
5

# ============================================================
# Test 4: Invalid model name produces clear error
# ============================================================

statement error
SELECT * FROM forecast('linear_trend', timestamp = 'ts', value = 'val', model = 'invalid');
----
Invalid model 'invalid'. Valid models: auto, ets, linear

# ============================================================
# Test 5: Linear model with perfectly linear data - forecast
#          should be exact continuation of the line
# ============================================================

# Perfect line: y = 10 + 3*x, last x=49, val=157
# Next predictions: x=50 -> 160, x=51 -> 163, x=52 -> 166
# With perfect data, predictions should be very close to exact
query T
SELECT abs(forecast - (10.0 + (49 + i) * 3.0)) < 0.01
FROM (
  SELECT forecast, row_number() OVER (ORDER BY forecast_timestamp) AS i
  FROM forecast('linear_trend', timestamp = 'ts', value = 'val', horizon = 3, model = 'linear')
);
----
true
true
true

# ============================================================
# Test 6: Confidence level affects interval width
# ============================================================

# Higher confidence (0.99) should produce wider intervals than lower (0.50)
query T
SELECT wide.spread > narrow.spread
FROM (
  SELECT max(upper_bound - lower_bound) AS spread
  FROM forecast('noisy_series', timestamp = 'ts', value = 'val', horizon = 3, model = 'linear', confidence_level = 0.99)
) wide,
(
  SELECT max(upper_bound - lower_bound) AS spread
  FROM forecast('noisy_series', timestamp = 'ts', value = 'val', horizon = 3, model = 'linear', confidence_level = 0.50)
) narrow;
----
true

# Same test with ETS model
query T
SELECT wide.spread >= narrow.spread
FROM (
  SELECT max(upper_bound - lower_bound) AS spread
  FROM forecast('noisy_series', timestamp = 'ts', value = 'val', horizon = 3, model = 'ets', confidence_level = 0.99)
) wide,
(
  SELECT max(upper_bound - lower_bound) AS spread
  FROM forecast('noisy_series', timestamp = 'ts', value = 'val', horizon = 3, model = 'ets', confidence_level = 0.50)
) narrow;
----
true

# ============================================================
# Test 7: Linear model prediction intervals are symmetric
# ============================================================

query T
SELECT abs((upper_bound - forecast) - (forecast - lower_bound)) < 0.001
FROM forecast('noisy_series', timestamp = 'ts', value = 'val', horizon = 1, model = 'linear');
----
true

# ============================================================
# Test 8: Linear model has lower_bound < forecast < upper_bound
# ============================================================

query I
SELECT count(*)
FROM forecast('noisy_series', timestamp = 'ts', value = 'val', horizon = 3, model = 'linear')
WHERE lower_bound < forecast AND forecast < upper_bound;
----
3

# ============================================================
# Test 9: Grouped forecast with model parameter
# ============================================================

# 2 groups * 3 horizon = 6 rows
query I
SELECT count(*)
FROM forecast('grouped_data', timestamp = 'ds', value = 'val', group_by = ['grp'], horizon = 3, model = 'linear');
----
6

# Both groups should appear
query I
SELECT count(DISTINCT grp)
FROM forecast('grouped_data', timestamp = 'ds', value = 'val', group_by = ['grp'], horizon = 2, model = 'linear');
----
2

# Grouped with ETS
query I
SELECT count(*)
FROM forecast('grouped_data', timestamp = 'ds', value = 'val', group_by = ['grp'], horizon = 3, model = 'ets');
----
6

# ============================================================
# Test 10: Output column types are correct for all models
# ============================================================

query TRRR
SELECT typeof(forecast_timestamp), typeof(forecast), typeof(lower_bound), typeof(upper_bound)
FROM forecast('linear_trend', timestamp = 'ts', value = 'val', horizon = 1, model = 'linear');
----
DATE	DOUBLE	DOUBLE	DOUBLE

# ============================================================
# Test 11: Timestamps are correct for linear model
# ============================================================

# Last data point: 2025-01-01 + 49 days = 2025-02-19
# First forecast: 2025-02-20
query T
SELECT forecast_timestamp
FROM forecast('linear_trend', timestamp = 'ts', value = 'val', horizon = 1, model = 'linear');
----
2025-02-20
