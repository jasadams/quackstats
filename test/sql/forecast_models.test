# name: test/sql/forecast_models.test
# group: quackstats

require quackstats

# ============================================================
# Setup: Create test data tables
# ============================================================

# Linear trend data (perfect line: y = 10 + 3*x)
statement ok
CREATE TABLE linear_trend AS
SELECT ('2025-01-01'::DATE + INTERVAL (i) DAY)::DATE AS ts,
       10.0 + i * 3.0 AS val
FROM generate_series(0, 49) t(i);

# Noisy data for interval width testing
statement ok
CREATE TABLE noisy_series AS
SELECT ('2025-01-01'::DATE + INTERVAL (i) DAY)::DATE AS ts,
       100.0 + i * 2.0 + (CASE WHEN i % 3 = 0 THEN 8.0 WHEN i % 3 = 1 THEN -5.0 ELSE 2.0 END) AS val
FROM generate_series(0, 39) t(i);

# Grouped data for grouped model tests
statement ok
CREATE TABLE grouped_data AS
SELECT ('2025-01-01'::DATE + INTERVAL (i) DAY)::DATE AS ds,
       grp,
       50.0 + i * 2.0 + (CASE WHEN grp = 'A' THEN 10 ELSE 0 END) AS val
FROM generate_series(0, 29) t(i),
     (VALUES ('A'), ('B')) AS groups(grp);

# ============================================================
# Test 1: model := 'ets' - explicit ETS model selection
# ============================================================

query I
SELECT count(*) FROM forecast('linear_trend', timestamp = 'ts', value = 'val', horizon = 5, model = 'ets');
----
6

# ETS forecast values should be positive and reasonable for upward trend (anchor also > 50)
query I
SELECT count(*) FROM forecast('linear_trend', timestamp = 'ts', value = 'val', horizon = 3, model = 'ets')
WHERE forecast > 50.0;
----
4

# ============================================================
# Test 2: model := 'linear' - linear regression model
# ============================================================

query I
SELECT count(*) FROM forecast('linear_trend', timestamp = 'ts', value = 'val', horizon = 5, model = 'linear');
----
6

# Linear model on trending data should continue the upward trend (anchor also > 100)
query I
SELECT count(*) FROM forecast('linear_trend', timestamp = 'ts', value = 'val', horizon = 3, model = 'linear')
WHERE forecast > 100.0;
----
4

# ============================================================
# Test 3: model := 'auto' - automatic model selection (default)
# ============================================================

query I
SELECT count(*) FROM forecast('linear_trend', timestamp = 'ts', value = 'val', horizon = 5, model = 'auto');
----
6

# Auto should also produce reasonable forecasts (anchor also > 50)
query I
SELECT count(*) FROM forecast('linear_trend', timestamp = 'ts', value = 'val', horizon = 3, model = 'auto')
WHERE forecast > 50.0;
----
4

# Default model (no model param) should behave same as 'auto'
query I
SELECT count(*) FROM forecast('linear_trend', timestamp = 'ts', value = 'val', horizon = 5);
----
6

# ============================================================
# Test 4: Invalid model name produces clear error
# ============================================================

statement error
SELECT * FROM forecast('linear_trend', timestamp = 'ts', value = 'val', model = 'invalid');
----
Invalid model 'invalid'. Valid models: auto, ets, linear

# ============================================================
# Test 5: Linear model with perfectly linear data - forecast
#          should be exact continuation of the line
# ============================================================

# Perfect line: y = 10 + 3*x, last x=49, val=157
# Anchor: x=49 -> 157, then x=50 -> 160, x=51 -> 163, x=52 -> 166
# With perfect data, predictions should be very close to exact
# Skip anchor row (i=0) and check forecast rows (i=1,2,3)
query T
SELECT abs(forecast - (10.0 + (49 + i) * 3.0)) < 0.01
FROM (
  SELECT forecast, row_number() OVER (ORDER BY forecast_timestamp) - 1 AS i
  FROM forecast('linear_trend', timestamp = 'ts', value = 'val', horizon = 3, model = 'linear')
);
----
true
true
true
true

# ============================================================
# Test 6: Confidence level affects interval width
# ============================================================

# Higher confidence (0.99) should produce wider intervals than lower (0.50)
query T
SELECT wide.spread > narrow.spread
FROM (
  SELECT max(upper_bound - lower_bound) AS spread
  FROM forecast('noisy_series', timestamp = 'ts', value = 'val', horizon = 3, model = 'linear', confidence_level = 0.99)
) wide,
(
  SELECT max(upper_bound - lower_bound) AS spread
  FROM forecast('noisy_series', timestamp = 'ts', value = 'val', horizon = 3, model = 'linear', confidence_level = 0.50)
) narrow;
----
true

# Same test with ETS model
query T
SELECT wide.spread >= narrow.spread
FROM (
  SELECT max(upper_bound - lower_bound) AS spread
  FROM forecast('noisy_series', timestamp = 'ts', value = 'val', horizon = 3, model = 'ets', confidence_level = 0.99)
) wide,
(
  SELECT max(upper_bound - lower_bound) AS spread
  FROM forecast('noisy_series', timestamp = 'ts', value = 'val', horizon = 3, model = 'ets', confidence_level = 0.50)
) narrow;
----
true

# ============================================================
# Test 7: Linear model prediction intervals are symmetric
# ============================================================

# Anchor row has lower_bound == upper_bound == forecast, so symmetry is trivially 0.
# Check both rows.
query T
SELECT abs((upper_bound - forecast) - (forecast - lower_bound)) < 0.001
FROM forecast('noisy_series', timestamp = 'ts', value = 'val', horizon = 1, model = 'linear');
----
true
true

# ============================================================
# Test 8: Linear model has lower_bound < forecast < upper_bound
# ============================================================

# Anchor row has lower_bound == forecast == upper_bound so it won't match strict <
# Only the 3 forecast rows match
query I
SELECT count(*)
FROM forecast('noisy_series', timestamp = 'ts', value = 'val', horizon = 3, model = 'linear')
WHERE lower_bound < forecast AND forecast < upper_bound;
----
3

# ============================================================
# Test 9: Grouped forecast with model parameter
# ============================================================

# 2 groups * (3 horizon + 1 anchor) = 8 rows
query I
SELECT count(*)
FROM forecast('grouped_data', timestamp = 'ds', value = 'val', group_by = ['grp'], horizon = 3, model = 'linear');
----
8

# Both groups should appear
query I
SELECT count(DISTINCT grp)
FROM forecast('grouped_data', timestamp = 'ds', value = 'val', group_by = ['grp'], horizon = 2, model = 'linear');
----
2

# Grouped with ETS
query I
SELECT count(*)
FROM forecast('grouped_data', timestamp = 'ds', value = 'val', group_by = ['grp'], horizon = 3, model = 'ets');
----
8

# ============================================================
# Test 10: Output column types are correct for all models
# ============================================================

query TRRR
SELECT typeof(forecast_timestamp), typeof(forecast), typeof(lower_bound), typeof(upper_bound)
FROM forecast('linear_trend', timestamp = 'ts', value = 'val', horizon = 1, model = 'linear')
LIMIT 1;
----
DATE	DOUBLE	DOUBLE	DOUBLE

# ============================================================
# Test 11: Timestamps are correct for linear model
# ============================================================

# Last data point: 2025-01-01 + 49 days = 2025-02-19 (anchor)
# Forecast: 2025-02-20
query T
SELECT forecast_timestamp
FROM forecast('linear_trend', timestamp = 'ts', value = 'val', horizon = 1, model = 'linear')
ORDER BY forecast_timestamp DESC LIMIT 1;
----
2025-02-20
